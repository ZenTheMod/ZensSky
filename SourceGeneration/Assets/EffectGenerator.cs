using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using static SourceGeneration.SourceGeneration;

namespace SourceGeneration.Assets;

[Generator(LanguageNames.CSharp)]
public sealed class EffectGenerator : IIncrementalGenerator
{
    private static readonly string[] Extensions = [".fx", ".hlsl"];

    private const string FileHeader = @"    // <Auto-Generated/>

using ReLogic.Content;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Terraria.ModLoader;
using System;

#pragma warning disable";

    /// <summary>
    /// Maps each hlsl type to a C# type, (Only includes types available for use with EffectParameter.SetValue (Excluding string)).
    /// </summary>
    private static readonly Dictionary<string, string> SupportedCSharpTypes = new()
    {
            // EffectParameter does not support strings, bytes or doubles.
        { "float", "float" },
        { "float2", "Vector2" },
        { "float3", "Vector3" },
        { "float4", "Vector4" },
        { "int", "int" },
        { "bool", "bool" },
            // Strangly EffectParameter.SetValue(Matrix) only accepts the following sizes: 2x2, 3x4, 4x3, 4x4.
        { "float2x2", "Matrix" },
        { "float3x4", "Matrix" },
        { "float4x3", "Matrix" },
        { "float4x4", "Matrix" },
        { "matrix", "Matrix" },
            // EffectParameter.SetValue allows for use of the base Texture class.
        { "texture", "Texture" },
    };
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var effectFiles = context.AdditionalTextsProvider
            .Where(static p =>
                Extensions.Any(ext => p.Path.EndsWith(ext, StringComparison.OrdinalIgnoreCase)) &&
                p.Path.Contains("Effects"))
            .Collect();

        context.RegisterSourceOutput(effectFiles, (context, path) =>
        {
            StringBuilder writer = new();

            foreach (AdditionalText effect in path)
            {
                string effectName = Path.GetFileNameWithoutExtension(effect.Path);

                    // Make sure the shader name is capitalized.
                effectName = effectName[0].ToString().ToUpper() + effectName[1..];

                string? source = effect.GetText()?.ToString();

                if (source is null)
                    continue;

                    // Lack of passes in this file usually indicates its a helper file, in which case it should be using the .fxh extension anyway.
                        // Match for the word 'pass'; could potentially be faulty but I doubt that that would come up.
                if (!Regex.IsMatch(source, "(?:^|\\W)pass(?:$|\\W)"))
                    continue;

                writer.AppendLine(FileHeader);

                    // Match for everything inbetween 'Effects/', and the file extension.
                string outputPath = Regex.Match(effect.Path, @"(?<=(Effects[\\/])).*?(?=\.([a-z]+)$)").Value;

                    // Match for everything inbetween (and including) '{ModName}/' where {ModName} is SourceGeneration.ModName, and the file extension.
                string assetPath = Regex.Match(effect.Path, @$"(?=({ModName}[\\/])).*?(?=\.([a-z]+)$)").Value;

                writer.AppendLine(@$"
namespace {Regex.Replace(assetPath, @"[\\/]", ".").Replace($".{effectName}", string.Empty)};

public static class {effectName}
{{
    private static readonly Lazy<Asset<Effect>> _shader = new(() => ModContent.Request<Effect>(""{Regex.Replace(assetPath, @"[\\/]", "/")}""));

    public static Asset<Effect> Shader => _shader.Value;

    public static Effect Value => Shader.Value;

    public static bool IsReady => Shader.IsLoaded && Value is not null;");

                string[] lines = source.Split([";", "}"], StringSplitOptions.RemoveEmptyEntries);

                int braces = 0;

                foreach (string line in lines)
                {
                    string[] items = line.Split(["\r\n", "\r", "\n", " "], StringSplitOptions.RemoveEmptyEntries);

                        // Don't interpret code inside braces as properties.
                            // Unsure of pontentially better ways to write this.
                    braces += Regex.Matches(line, "[({]").Count;
                    braces -= Regex.Matches(line, "[)}]").Count;

                    if (braces > 0)
                        continue;

                    if (items.Length < 2)
                        continue;

                    if (!SupportedCSharpTypes.TryGetValue(items[0], out string? typeName) || typeName is null)
                        continue;

                    string parameterName = items[1];

                    string propertyName = items[1];

                        // Remove the 'u' prefix if applicable; commonly found on parameter names.
                    propertyName = Regex.Replace(propertyName, "^u?(?=[A-Z])", string.Empty);

                        // Make sure the property name is capitalized.
                    propertyName = propertyName[0].ToString().ToUpper() + propertyName[1..];

                        // Imperfect method of checking for arrays (seeing as multidimensional arrays are unsupported) but it'll do the trick.
                            // (This may break with textures as theres no EffectParameter.SetValue(Texture[]), but the chances of that ever being relivant are rather slim.)
                    if (propertyName.EndsWith("]"))
                    {
                            // Remove the array initialization from the parameter name.
                        parameterName = Regex.Match(parameterName, ".*?(?=\\[)").Value;
                        propertyName = Regex.Match(propertyName, ".*?(?=\\[)").Value;
                        typeName += "[]";
                    }

                        // TODO: Potental get method impl using EffectParameter's scattered methods; Although, when has anyone used those?
                    writer.AppendLine(@$"
    public static {typeName} {propertyName} {{ set => Value.Parameters[""{parameterName}""].SetValue(value); }}");
                }

                writer.AppendLine(@$"
    public static void Apply(int pass = 0) => Value.CurrentTechnique.Passes[pass].Apply();");

                writer.Append(@$"}}");

                context.AddSource(outputPath + ".cs", writer.ToString());

                writer.Clear();
            }
        });
    }
}
