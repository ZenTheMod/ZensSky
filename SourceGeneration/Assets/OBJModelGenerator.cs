using Microsoft.CodeAnalysis;
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using static SourceGeneration.SourceGeneration;

namespace SourceGeneration.Assets;

[Generator(LanguageNames.CSharp)]
public sealed class OBJModelGenerator : IIncrementalGenerator
{
    private const string Extension = ".obj";

    private const string FileHeader = @$"    // <Auto-Generated/>

using ReLogic.Content;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Terraria.ModLoader;
using System;
using {ModName}.Core.DataStructures;

#pragma warning disable";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var objFiles = context.AdditionalTextsProvider
            .Where(static p =>
                p.Path.EndsWith(Extension, StringComparison.OrdinalIgnoreCase) &&
                p.Path.Contains("Models"))
            .Collect();

        context.RegisterSourceOutput(objFiles, (context, path) =>
        {
            StringBuilder writer = new();

            foreach (AdditionalText model in path)
            {
                string modelName = Path.GetFileNameWithoutExtension(model.Path);

                    // Make sure the shader name is capitalized.
                modelName = modelName[0].ToString().ToUpper() + modelName[1..];

                string? source = model.GetText()?.ToString();

                if (source is null)
                    continue;

                writer.AppendLine(FileHeader);

                    // Match for everything inbetween 'Models/', and the file extension.
                string outputPath = Regex.Match(model.Path, @"(?<=(Models[\\/])).*?(?=\.([a-z]+)$)").Value;

                    // Match for everything inbetween (and including) '{ModName}/' where {ModName} is SourceGeneration.ModName, and the file extension.
                string assetPath = Regex.Match(model.Path, @$"(?=({ModName}[\\/])).*?(?=\.([a-z]+)$)").Value;

                writer.AppendLine(@$"
namespace {Regex.Replace(assetPath, @"[\\/]", ".").Replace($".{modelName}", string.Empty)};

public static class {modelName}
{{
    private static readonly Lazy<Asset<OBJModel>> _model = new(() => ModContent.Request<OBJModel>(""{Regex.Replace(assetPath, @"[\\/]", "/")}""));

    public static Asset<OBJModel> Model => _model.Value;

    public static OBJModel Value => Model.Value;

    public static bool IsReady => Model.IsLoaded && Value is not null;");

                    // Only grab lines corresponding to mesh names.
                string[] lines = [.. source.Split(["\r\n", "\r", "\n"], StringSplitOptions.None)
                    .Where(s => s.Length >= 3 && s[0] == 'o')]; // Also remember blank lines exsist.

                    // Create individual draw methods for each mesh using its name.
                for (int i = 0; i < lines.Length; i++)
                {
                    string line = lines[i];

                    if (line.Length <= 3)
                        continue;

                        // Remove all spaces and hyphenation and convert the name to PascalCase.
                    string meshName = string.Empty;
                    string[] meshNameParts = line[2..].Split(' ', '_', '-');

                    foreach (string part in meshNameParts)
                    {
                        if (part.Length <= 2)
                            continue;

                        meshName += part[0].ToString().ToUpper() + part[1..];
                    }

                    writer.AppendLine(@$"
    public static void Draw{meshName}(GraphicsDevice device) => Value.Draw(device, {i});");
                }

                writer.Append(@$"}}");

                context.AddSource(outputPath + ".cs", writer.ToString());

                writer.Clear();
                }
        });
    }
}
